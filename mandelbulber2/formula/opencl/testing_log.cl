/**
 * Mandelbulber v2, a 3D fractal generator  _%}}i*<.        ____                _______
 * Copyright (C) 2020 Mandelbulber Team   _>]|=||i=i<,     / __ \___  ___ ___  / ___/ /
 *                                        \><||i|=>>%)    / /_/ / _ \/ -_) _ \/ /__/ /__
 * This file is part of Mandelbulber.     )<=i=]=|=i<>    \____/ .__/\__/_//_/\___/____/
 * The project is licensed under GPLv3,   -<>>=|><|||`        /_/
 * see also COPYING file in this folder.    ~+{i%+++
 *
 * Quaternion4D

 * This file has been autogenerated by tools/populateUiInformation.php
 * from the file "fractal_quaternion4d.cpp" in the folder formula/definition
 * D O    N O T    E D I T    T H I S    F I L E !
 */

REAL4 TestingLogIteration(REAL4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	// REAL colorAdd = 0.0f;
	aux->DE = mad(2.0f * aux->DE, aux->r, 1.0f);

	//  pre-abs
	if (fractal->transformCommon.functionEnabledAFalse
			&& aux->i >= fractal->transformCommon.startIterationsA
			&& aux->i < fractal->transformCommon.stopIterationsA)
	{
		if (fractal->transformCommon.functionEnabledAxFalse) z.x = fabs(z.x);
		if (fractal->transformCommon.functionEnabledAyFalse) z.y = fabs(z.y);
		if (fractal->transformCommon.functionEnabledAzFalse) z.z = fabs(z.z);
	}

	REAL4 ZZ = z * z;
	REAL rr = ZZ.x + ZZ.y;
	REAL theta = atan2(z.z, native_sqrt(rr));
	rr += ZZ.z;
	REAL phi = atan2(z.y, z.x);
	REAL thetatemp = theta;

	/*if(usespin)if(spin)
		{
			theta = -theta;
	if(theta > 0.0f)
	{
		theta = -pi1p5 + theta;
	}
	else
	{
		REAL alpha = pi0p5 + theta;
		theta = M_PI_F + alpha;
	}
	theta = theta + M_PI_F;
	}*/

	REAL phi_pow = mad(2.0f, phi, M_PI_F);
	REAL theta_pow =
		theta + M_PI_F + native_divide(M_PI_F, 2.0f); // piAdd;+ native_divide(M_PI_F, 2.0f)
	if (fractal->transformCommon.functionEnabledBFalse)
		theta_pow = theta + native_divide(M_PI_F, 4.0f);
	// theta_pow = theta + thetatemp + native_divide(M_PI_F, 2.0f);
	if (fractal->transformCommon.functionEnabledCFalse) theta_pow = theta + thetatemp + M_PI_F;

	REAL rn_sin_theta_pow = rr * native_sin(theta_pow);
	z.x = rn_sin_theta_pow * native_cos(phi_pow); //  + jx
	z.y = rn_sin_theta_pow * native_sin(phi_pow); // + jy
	z.z = rr * native_cos(theta_pow); //  + jz

	// z+=(Julia ? JuliaC : pos);
	/*if(usespin)
	{
		if(spin)
		{
			theta += thetatemp - piAdd;
					if(theta > pi1p5) spin = !spin;
		else
		{
		if(theta < pi0p5) spin = !spin;
		}
		}
		else
	{
			if(theta > pi0p25) spin = !spin;
			 else if(theta < -pi0p25) spin = !spin;
		}
	}*/

	// DE tweak
	if (fractal->analyticDE.enabledFalse)
			aux->DE = mad(aux->DE, fractal->analyticDE.scale1, fractal->analyticDE.offset0);
	return z;
}
