/**
 * Mandelbulber v2, a 3D fractal generator  _%}}i*<.        ____                _______
 * Copyright (C) 2023 Mandelbulber Team   _>]|=||i=i<,     / __ \___  ___ ___  / ___/ /
 *                                        \><||i|=>>%)    / /_/ / _ \/ -_) _ \/ /__/ /__
 * This file is part of Mandelbulber.     )<=i=]=|=i<>    \____/ .__/\__/_//_/\___/____/
 * The project is licensed under GPLv3,   -<>>=|><|||`        /_/
 * see also COPYING file in this folder.    ~+{i%+++
 *
 * formula by TGlad,
 * https://fractalforums.org/fractal-mathematics-and-new-theories/28/fractal-clusters/5107

 * This file has been autogenerated by tools/populateUiInformation.php
 * from the file "fractal_sphere_cluster.cpp" in the folder formula/definition
 * D O    N O T    E D I T    T H I S    F I L E !
 */

REAL4 SpheretreeV5Iteration(REAL4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	REAL t = 0.0f;
	REAL4 oldZ = z;
	REAL col = 0.0f;
	REAL4 ColV = (REAL4){0.0f, 0.0f, 0.0f, 0.0f};
	REAL3 p = (REAL3){z.x, z.y, z.z}; // convert to vec3
	if (fractal->transformCommon.functionEnabledDFalse)	aux->DE = 1.0f;

	p *= fractal->transformCommon.scaleG1; // master aux->DE
	aux->DE *= fractal->transformCommon.scaleG1;

	REAL3 K3 = (REAL3){0.0f, 0.0f, 0.0f};

	int Iterations = fractal->transformCommon.int32;
	bool StartCurved = fractal->transformCommon.functionEnabledFalse;
	REAL BendAngle = fractal->transformCommon.scale08;
	int NumChildren = fractal->transformCommon.int8X;


	REAL o1 = 3.0;
	if (NumChildren <= 4)
		o1 = 5.0;
	else if (NumChildren <= 6)
		o1 = 4.0;
	REAL o2 = fractal->transformCommon.offset3;
	REAL phi = (1.0 + sqrt(5.0)) / 2.0;
	int n = NumChildren;
	REAL sec = 1.0 / cos(M_PI_F / o1);
	REAL csc = 1.0 / sin(M_PI_F / n);
	REAL r = sec / sqrt(csc * csc - sec * sec);

	REAL l = sqrt(1.0 + r * r);

	REAL theta = asin(r * sin(M_PI_F - M_PI_F / o2) / l);
	REAL L4 = l * sin(M_PI_F / o2 - theta) / sin(M_PI_F - M_PI_F / o2);
	REAL minr = L4 * L4;


	REAL bend = BendAngle;
	/*REAL omega = M_PI_F / 2.0 - bend;
	REAL bigR = 1.0 / cos(omega);
	REAL d = tan(omega);*/

	bool recurse = StartCurved;
	for (int i = 0; i < Iterations; i++)
	{		REAL omega = M_PI_F / 2.0 - bend;
		REAL bigR = 1.0 / cos(omega);
		REAL d = tan(omega);
		if (recurse)
		{
			p -= (REAL3)(0.0, 0.0, -d - bigR);
			REAL sc = 4.0 * bigR * bigR / dot(p, p);
			p *= sc;
			aux->DE *= sc;
			p += (REAL3)(0.0, 0.0, -2.0 * bigR);
			p.z = -p.z;
			REAL size = 2.0 * bigR / (bigR + d);
			aux->DE /= size;
			p /= size;
			recurse = false;
		}
		REAL angle = atan2(p.y, p.x);
		if (angle < 0.0) angle += 2.0 * M_PI_F;
		angle = fmod(angle, 2.0 * M_PI_F / n);
		REAL mag = sqrt(p.x * p.x + p.y * p.y);
		p.x = mag * cos(angle);
		p.y = mag * sin(angle);

		REAL ang1 = M_PI_F / n;
		REAL3 circle_centre = l * (REAL3)(cos(ang1), sin(ang1), 0.0);
		REAL3 temp = p - circle_centre;
		REAL len = length(temp);
		if (len < r)
		{
			REAL sc = r * r / (len * len);
			temp *= sc;
			aux->DE *= sc;
		}
		p = temp + circle_centre;

		REAL o2 = bend / 2.0;
		REAL d2 = minr * tan(o2);
		REAL R2 = minr / cos(o2);
		REAL3 mid_offset = (REAL3)(0.0, 0.0, d2);
		REAL amp = length(p - mid_offset);
		//   REAL mag4 = sqrt(p[0]*p[0] + p[1]*p[1]);
		if (amp <= R2) // || mag4 <= minr)
		{
			p /= minr;
			aux->DE /= minr;
			recurse = true;
		}
		else if (length(p) < L4)
		{
			REAL sc = L4 * L4 / dot(p, p);
			p *= sc;
			aux->DE *= sc;
		}
		bend *= fractal->transformCommon.scale1; // PackRatioScale;
		// post aux->DE
		p *= fractal->transformCommon.scaleF1;
		aux->DE *= fabs(fractal->transformCommon.scaleF1);
		// DE tweaks
		aux->DE = aux->DE * fractal->analyticDE.scale1 + fractal->analyticDE.offset0;

	/*	if (fractal->foldColor.auxColorEnabled && n >= fractal->foldColor.startIterationsA
				&& n < fractal->foldColor.stopIterationsA)
		{
			col += ColV.y * fractal->foldColor.difs0000.y + ColV.z * fractal->foldColor.difs0000.z;
			if (fractal->foldColor.difs1 > dist) col += fractal->foldColor.difs0000.w;
		}*/
	}

	z = (REAL4){p.x, p.y, p.z, z.w};

	REAL dt;
	{
		if (!fractal->transformCommon.functionEnabledSwFalse) dt = p.z / aux->DE;
		else dt = (length(z)- fractal->analyticDE.offset1)/ aux->DE;

	}


/*
	if (!fractal->transformCommon.functionEnabledSwFalse)
	{
		if (!fractal->transformCommon.functionEnabledEFalse)
		{
			d = k;
		}
		else
		{
			d = min(1.0f, k);
		}

		d = minr * fractal->transformCommon.aux->DEE1 * d;

		if (!fractal->transformCommon.functionEnabledOFalse)
		{
			d = (length(z) - d) / aux->DE;
		}
		else
		{
			bool negate = false;

			REAL den = length(K3);

			REAL radius = d;
			REAL3 target = (REAL3){0.0f, 0.0f, 0.0f};
			if (den > 1e-13f)
			{
				REAL3 offset = K3 / den;
				offset *= aux->DE; // since K is normalised to the aux->DE
				REAL rad = length(offset);
				offset += p;

				target -= offset;
				REAL mag = length(target);
				if (fabs(radius / mag) > 1.0f) negate = true;

				REAL3 t1 = target * (1.0f - radius / mag);
				REAL3 t2 = target * (1.0f + radius / mag);
				t1 *= rad * rad / dot(t1, t1);
				t2 *= rad * rad / dot(t2, t2);
				REAL3 mid = (t1 + t2) / 2.0f;
				radius = length(t1 - t2) / 2.0f;
				target = mid + offset;
			}

			REAL dist = (length(p - target) - radius);

			if (negate) dist = -dist;

			d = dist / aux->DE;
		}
	}
	else
	{
		REAL4 zc = z - fractal->transformCommon.offset000;
		if (fractal->transformCommon.functionEnabledFFalse) zc = fabs(zc);
		d = max(max(zc.x, zc.y), zc.z);
		d = (d - minr * k) / aux->DE;
	}*/

	if (fractal->transformCommon.functionEnabledCFalse)
	{
		REAL dst1 = length(aux->const_c) - fractal->transformCommon.offsetR1;
		dt = max(dt, dst1);
		dt = fabs(dt);
	}

	if (!fractal->transformCommon.functionEnabledXFalse)
		aux->dist = min(aux->dist, dt);
	else
		aux->dist = dt;

	if (fractal->analyticDE.enabledFalse) z = oldZ;

	aux->color = col;
	return z;
}
