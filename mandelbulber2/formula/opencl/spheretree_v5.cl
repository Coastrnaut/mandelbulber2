/**
 * Mandelbulber v2, a 3D fractal generator  _%}}i*<.        ____                _______
 * Copyright (C) 2023 Mandelbulber Team   _>]|=||i=i<,     / __ \___  ___ ___  / ___/ /
 *                                        \><||i|=>>%)    / /_/ / _ \/ -_) _ \/ /__/ /__
 * This file is part of Mandelbulber.     )<=i=]=|=i<>    \____/ .__/\__/_//_/\___/____/
 * The project is licensed under GPLv3,   -<>>=|><|||`        /_/
 * see also COPYING file in this folder.    ~+{i%+++
 *
 * formula by TGlad, extras by sabine62
 * https://fractalforums.org/fractal-mathematics-and-new-theories/28/new-sphere-tree/3557/msg22100#msg22100

 * This file has been autogenerated by tools/populateUiInformation.php
 * from the file "fractal_spheretree_v5.cpp" in the folder formula/definition
 * D O    N O T    E D I T    T H I S    F I L E !
 */

REAL4 SpheretreeV5Iteration(REAL4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{

	REAL t = 0.0f;
	REAL3 tv = (REAL3){0.0f, 0.0f, 0.0f};
	REAL4 oldZ = z;
	REAL col = 0.0f;
	REAL4 ColV = (REAL4){0.0f, 0.0f, 0.0f, 0.0f};
	REAL3 p = (REAL3){z.x, z.y, z.z}; // convert to vec3
	if (fractal->transformCommon.functionEnabledDFalse) aux->DE = 1.0f;
	REAL dist_to_sphere = length(p) - fractal->transformCommon.radius1;
	p *= fractal->transformCommon.scaleG1; // master scale
	aux->DE *= fractal->transformCommon.scaleG1;

	REAL3 K3 = tv;

	int Iterations = fractal->transformCommon.int32;
	int NumChildren = fractal->transformCommon.int8X;
	bool StartCurved = fractal->transformCommon.functionEnabledFalse;
	REAL BendAngle = fractal->transformCommon.scale08;

	REAL o1 = 3.0f;
	if (NumChildren <= 4)
		o1 = 5.0f;
	else if (NumChildren <= 6)
		o1 = 4.0f;
	REAL o2 = fractal->transformCommon.offset3;

	int n = NumChildren;
	REAL sec = 1.0f / native_cos(M_PI_F / o1);
	REAL csc = 1.0f / native_sin(M_PI_F / n);
	REAL r = sec / native_sqrt(csc * csc - sec * sec);

	REAL l = native_sqrt(1.0f + r * r);

	REAL theta = asin(r * native_sin(M_PI_F - M_PI_F / o2) / l);
	REAL L4 = l * native_sin(M_PI_F / o2 - theta) / native_sin(M_PI_F - M_PI_F / o2);
	REAL minr = L4 * L4;

	REAL bend = BendAngle;

	REAL omega = 0.0;
	REAL bigR = 0.0;
	REAL d = 0.0;
	if (!fractal->transformCommon.functionEnabledzFalse)
	{
		omega = M_PI_F / 2.0f - bend;
		bigR = 1.0f / native_cos(omega);
		d = tan(omega);
	}

	bool recurse = StartCurved;
	for (int i = 0; i < Iterations; i++)
	{
		if (fractal->transformCommon.functionEnabledzFalse)
		{
			omega = M_PI_F / 2.0f - bend;
			bigR = 1.0f / native_cos(omega);
			d = tan(omega);
		}

		if (recurse && i >= fractal->transformCommon.startIterationsC
				&& i < fractal->transformCommon.stopIterationsC)
		{
			p.z += d + bigR;
			REAL sc = 4.0f * bigR * bigR / dot(p, p);
			p *= sc;
			aux->DE *= sc;
			p.z += -2.0f * bigR;
			p.z = -p.z;
			REAL invSize = (bigR + d) / (2.0f * bigR);
			aux->DE *= invSize;
			p *= invSize;
			recurse = false;
		}
		REAL angle = atan2(p.y, p.x);
		if (angle < 0.0f) angle += 2.0f * M_PI_F;
		angle = fmod(angle, 2.0f * M_PI_F / n);
		REAL mag = native_sqrt(p.x * p.x + p.y * p.y);
		p.x = mag * native_cos(angle);
		p.y = mag * native_sin(angle);

		REAL ang1 = M_PI_F / n;
		REAL3 circle_centre = l * (REAL3){native_cos(ang1), native_sin(ang1), 0.0f};
		tv = p - circle_centre;
		REAL len = length(tv);
		if (len < r)
		{
			ColV.x += 1.0f;
			REAL sc = r * r / (len * len);
			tv *= sc;
			aux->DE *= sc;
		}
		p = tv + circle_centre;

		o2 = bend / 2.0f;
		REAL d2 = minr * tan(o2);
		REAL R2 = minr / native_cos(o2);
		REAL3 mid_offset = (REAL3){0.0f, 0.0f, d2};
		tv = p - mid_offset * fractal->transformCommon.scaleA1;
		REAL amp = length(tv) * fractal->transformCommon.scaleD1;
		// REAL mag4 = native_sqrt(p[0]*p[0] + p[1]*p[1]);
		if (amp <= R2 - fractal->transformCommon.scale0) // mmmmmmmmmmmmmmmmmmmmmmm // || mag4 <= minr)
		{
			ColV.z += 1.0f;
			t = 1.0f / minr;
			p *= t;
			aux->DE *= t;
			recurse = true;
		}
		else if (length(p) < L4)
		{
			ColV.w += 1.0f;
			REAL sc = L4 * L4 / dot(p, p);
			p *= sc;
			aux->DE *= sc;
		}
		if (i >= fractal->transformCommon.startIterationsA
				&& i < fractal->transformCommon.stopIterationsA)
		{bend *= fractal->transformCommon.scaleB1;}

		// post scale
		p *= fractal->transformCommon.scaleC1;
		aux->DE *= fabs(fractal->transformCommon.scaleC1);
		// DE tweaks
		aux->DE = aux->DE * fractal->analyticDE.scale1 + fractal->analyticDE.offset0;

		ColV.y += length(p);

		if (fractal->foldColor.auxColorEnabled && i >= fractal->foldColor.startIterationsA
				&& i < fractal->foldColor.stopIterationsA)
		{
			col += ColV.x * fractal->foldColor.difs0000.x + ColV.y * fractal->foldColor.difs0000.y
					 + ColV.z * fractal->foldColor.difs0000.z + ColV.w * fractal->foldColor.difs0000.w;
		}
	}

	z = (REAL4){p.x, p.y, p.z, z.w};

	REAL dt;

	if (!fractal->transformCommon.functionEnabledEFalse)
		dt = (length(z) - fractal->transformCommon.offset0) / aux->DE;
	else
		dt = (p.z - fractal->transformCommon.offset0) / aux->DE;





	/*	REAL d;
		if (!fractal->transformCommon.functionEnabledSwFalse)
		{
			if (!fractal->transformCommon.functionEnabledEFalse)
			{
				d = k;
			}
			else
			{
				d = min(1.0f, k);
			}

			d = minr * fractal->transformCommon.scaleE1 * d;

			if (!fractal->transformCommon.functionEnabledOFalse)
			{
				d = (length(z) - d) / aux->DE;
			}
			else
			{
				bool negate = false;

				REAL den = length(K3);

				REAL radius = d;
				REAL3 target = (CVector3){0.0f, 0.0f, 0.0f};
				if (den > 1e-13f)
				{
					REAL3 offset = K3 / den;
					offset *= aux->DE; // since K is normalised to the scale
					REAL rad = length(offset);
					offset += p;

					target -= offset;
					REAL mag = length(target);
					if (fabs(radius / mag) > 1.0f) negate = true;

					REAL3 t1 = target * (1.0f - radius / mag);
					REAL3 t2 = target * (1.0f + radius / mag);
					t1 *= rad * rad / dot(t1, t1);
					t2 *= rad * rad / dot(t2, t2);
					REAL3 mid = (t1 + t2) / 2.0f;
					radius = length(t1 - t2) / 2.0f;
					target = mid + offset;
				}

				REAL dist = (length(p - target) - radius);

				if (negate) dist = -dist;

				d = dist / aux->DE;
			}
		}
		else
		{
			REAL4 zc = z - fractal->transformCommon.offset000;
			if (fractal->transformCommon.functionEnabledFFalse) zc = fabs(zc);
			d = max(max(zc.x, zc.y), zc.z);
			d = (d - minr * k) / aux->DE;
		}*/

	if (fractal->transformCommon.functionEnabledCFalse)
	{
		REAL dst1 = length(aux->const_c) - fractal->transformCommon.offsetR1;
		dt = max(dt, dst1);
		dt = fabs(dt);
	}


	if (fractal->transformCommon.functionEnabledYFalse) dt = max(dist_to_sphere, dt);


	if (!fractal->transformCommon.functionEnabledXFalse)
		aux->dist = min(aux->dist, dt);
	else
		aux->dist = dt;

	if (fractal->analyticDE.enabledFalse) z = oldZ;

	aux->color += col;

	return z;
}
